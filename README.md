# Описание работы алгоритма

Общая идея алгоритма - найти минимальный путь, состоящий из суммы двух: прямого и обратного.

Прямой путь - путь, проходящий через все вершины графа. Конечная вершина при этом может быть любой.

Обратный путь - самый короткий путь от конечной вершины прямого пути до начальной.


## Поиск обратного пути

В рамках данной задачи нас интересует только длина пути. Следовательно, можно найти длины маршрутов от начальной вершины до всех остальных и использовать их. Пути можно найти любым удобным способом. В работе в функции `find_all_paths` реализован алгоритм Дейкстры. Длины всех обратных путей хранятся в переменной `back_paths`.


## Поиск прямого пути
Прямой путь вычисляется итеративно методом ближайшего соседа. Для этого формируется граф (переменная `graph`, представляющая собой словарь формата `{вершина: соседи}`), причем соседи для каждой вершины соритруются по возрастанию расстояния.

В функции `min_path_calculate` реализован рекурсивный обход графа. В функции постоянно хранится весь текущий маршрут, состоящий из пройденных ребер. 

Для уменьшения времени работы алгоритма введено ограничение на количество ребер в пути. Без ограничения алгоритм сводится к полному перебору.

В данной версии программы подобрано число n+3, то есть алгоритм может зайти в уже пройденную вершину лишь трижды. К сожалению, число необходимо подбирать. Очевидно, что оно должно быть больше для графов, в которых присутствует большое число вершин с одним ребром.

Благодаря предварительной сортировке повышается вероятность найти кратчайший путь в условиях описанного выше ограничения.

Если пройдены все вершины, производится расчет длины полного пути с учетом обратной дороги в функции `full_path_calculate`, а результат сравнивается с уже существующим.
